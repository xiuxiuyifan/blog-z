<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>堆栈内存和数据类型</title>
</head>
<body>
    <script>
        // console.log(typeof NaN)  // 'number'
        // console.log(NaN == NaN)  // false
        // let a = NaN
        // console.log(a == a)      // false

        // let x = 10
        // if(isNaN(x)) {     // 进不来
        //     console.log('是真的有效数字')
        // }

        // console.log(Object.is(NaN, NaN))   // true 可以理解成 === 只是对 NaN做了特殊的处理

        // let s = Symbol('aa')
        // console.log(s == s)  // true  与 NaN 不一样
        // console.log(Symbol('aa') == Symbol('aa'))  // false  可以理解为比地址

        // let res = parseFloat('left:200px')
        // if(res === 200) {
        //     alert(200)
        // }else if(res === NaN) {   // NaN === NaN   false
        //     alert(NaN)
        // }else if(typeof res === 'number') {
        //     // typeof NaN === 'number'
        //     alert('number')
        // }else {
        //     alert('Invalid Number')
        // }


        // var a = 10
        // var b = a
        // b = 999
        // console.log(a)  // 10 值拷贝赋值

        // var obj = {
        //     val: 10
        // }
        // var obj1 = obj        // 指向同一个堆内存空间
        // obj1.val = 999
        // console.log(obj.val)  // 999 

        // var o = {
        //     val: 10
        // }
        // var o1 = o   // o o1 执行同一个堆内存空间
        // o1 = {       // 把 o1 重新指向
        //     val: 999
        // }
        // console.log(o.val)   // 10 

        // var a = {}
        //     b = '0'
        //     c = 0;
        // a[b] = 999
        // a[c] = 1
        // console.log(a[b])

        // var a = {}
        // var b = Symbol('1')
        // var c = Symbol('1')
        // a[b] = 99
        // a[c] = 100

        // console.log(a[b])  // 99

        // var a = {}
        // var b = {
        //     val: 100
        // }
        // var c = {
        //     val: 99
        // }
        // a[b] = 1
        // a[c] = 10
        // console.log(a[b])   // 10

        // var a = {n: 1}
        // var b = a
        // a.x = a = {n: 2}
        // console.log(a.x)  // undefined
        // console.log(b)    // {n:1,x:{n:2}}


        // var x = [12, 23]
        // function fn(y) {
        //     y[0] = 100
        //     y = [100]
        //     y[1] = 200
        //     console.log(y) // [100, 200]
        // }
        // fn(x)   
        // console.log(x)    // [100, 23]


        // console.log(Number(''))     // 0
        // console.log(Number('10'))   // 10
        // console.log(Number('10px')) // NaN
        // console.log(Number(true))   // 1
        // console.log(Number(false))  // 0
        // console.log(Number(null))   // 0
        // console.log(Number(undefined))  // NaN
        // console.log(Number(Symbol(10))) // 报错
        // console.log(Number(BigInt(10))) // 10

        // 对象转为数字，应该先valueOf() ,没有原始值再toString变为字符串，最后把字符串转为数字

        // parseInt机制：从字符串左侧第一个字符开始（忽略空白字符），查找有效数字字符串（遇到非有效数字字符停止查找，不论后面是否还有数字字符，都不再找了）
        // 把找到的有效数字字符串转为数字，如果一个都没有找到结果就是 NaN（parseFloat比他多识别一个小数点）

    </script>
</body>
</html>


